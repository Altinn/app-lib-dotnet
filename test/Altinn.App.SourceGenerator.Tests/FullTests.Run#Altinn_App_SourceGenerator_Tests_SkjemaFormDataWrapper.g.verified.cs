//HintName: Altinn_App_SourceGenerator_Tests_SkjemaFormDataWrapper.g.cs
// <auto-generated/>
#nullable enable

public class Altinn_App_SourceGenerator_Tests_SkjemaFormDataWrapper
    : global::Altinn.App.Core.Features.IFormDataWrapper<global::Altinn.App.SourceGenerator.Tests.Skjema>
{
    private readonly global::Altinn.App.SourceGenerator.Tests.Skjema _dataModel;

    public global::System.Type BackingDataType => typeof(global::Altinn.App.SourceGenerator.Tests.Skjema);

    public T BackingData<T>()
        where T : class
    {
        return _dataModel as T
            ?? throw new global::System.InvalidCastException(
                $"Attempted to cast data model of type Altinn.App.SourceGenerator.Tests.Skjema to {typeof(T).FullName}"
            );
    }

    public Altinn_App_SourceGenerator_Tests_SkjemaFormDataWrapper(object dataModel)
    {
        _dataModel =
            dataModel as global::Altinn.App.SourceGenerator.Tests.Skjema
            ?? throw new global::System.ArgumentException(
                $"Data model must be of type Altinn.App.SourceGenerator.Tests.Skjema, (was {dataModel.GetType().FullName})"
            );
    }

    #region Getters

    /// <inheritdoc />
    public object? Get(global::System.ReadOnlySpan<char> path)
    {
        if (path.IsEmpty)
        {
            return null;
        }

        return GetRecursive(_dataModel, path, 0);
    }

    private static object? GetRecursive(
        global::Altinn.App.SourceGenerator.Tests.Skjema? model,
        global::System.ReadOnlySpan<char> path,
        int offset
    )
    {
        return GetNextSegment(path, offset, out int nextOffset) switch
        {
            "skjemanummer" when nextOffset is -1 => model?.Skjemanummer,
            "skjemaversjon" when nextOffset is -1 => model?.Skjemaversjon,
            "skjemainnhold" => GetRecursive(model?.Skjemainnhold, path, nextOffset),
            "eierAdresse" => GetRecursive(model?.EierAdresse, path, nextOffset),
            "" => model,
            // _ => throw new global::System.ArgumentException("{path} is not a valid path."),
            _ => null,
        };
    }

    private static object? GetRecursive(
        global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Tests.SkjemaInnhold?>? model,
        global::System.ReadOnlySpan<char> path,
        int offset
    )
    {
        int index = GetIndex(path, offset, out int nextOffset);
        if (index < 0 || index >= model?.Count)
        {
            // throw new global::System.IndexOutOfRangeException($"Index {index} is out of range for list of length {model.Count}.");
            return null;
        }

        return GetRecursive(model?[index], path, nextOffset);
    }

    private static object? GetRecursive(
        global::Altinn.App.SourceGenerator.Tests.SkjemaInnhold? model,
        global::System.ReadOnlySpan<char> path,
        int offset
    )
    {
        return GetNextSegment(path, offset, out int nextOffset) switch
        {
            "altinnRowId" when nextOffset is -1 => model?.AltinnRowId,
            "navn" when nextOffset is -1 => model?.Navn,
            "alder" when nextOffset is -1 => model?.Alder,
            "deltar" when nextOffset is -1 => model?.Deltar,
            "adresse" => GetRecursive(model?.Adresse, path, nextOffset),
            "tidligere-adresse" => GetRecursive(model?.TidligereAdresse, path, nextOffset),
            "" => model,
            // _ => throw new global::System.ArgumentException("{path} is not a valid path."),
            _ => null,
        };
    }

    private static object? GetRecursive(
        global::Altinn.App.SourceGenerator.Tests.Adresse? model,
        global::System.ReadOnlySpan<char> path,
        int offset
    )
    {
        return GetNextSegment(path, offset, out int nextOffset) switch
        {
            "altinnRowId" when nextOffset is -1 => model?.AltinnRowId,
            "gate" when nextOffset is -1 => model?.Gate,
            "postnummer" when nextOffset is -1 => model?.Postnummer,
            "poststed" when nextOffset is -1 => model?.Poststed,
            "" => model,
            // _ => throw new global::System.ArgumentException("{path} is not a valid path."),
            _ => null,
        };
    }

    private static object? GetRecursive(
        global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Tests.Adresse>? model,
        global::System.ReadOnlySpan<char> path,
        int offset
    )
    {
        int index = GetIndex(path, offset, out int nextOffset);
        if (index < 0 || index >= model?.Count)
        {
            // throw new global::System.IndexOutOfRangeException($"Index {index} is out of range for list of length {model.Count}.");
            return null;
        }

        return GetRecursive(model?[index], path, nextOffset);
    }

    #endregion Getters
    #region AddIndexToPath

    /// <inheritdoc />
    public global::System.ReadOnlySpan<char> AddIndexToPath(global::System.ReadOnlySpan<char> path, global::System.ReadOnlySpan<int> rowIndexes, global::System.Span<char> buffer)
    {
        var bufferOffset = 0;
        var pathOffset = 0;

        AddIndexToPathRecursive_Altinn_App_SourceGenerator_Tests_Skjema(
            path,
            pathOffset,
            rowIndexes,
            buffer,
            ref bufferOffset
        );

        return buffer[..bufferOffset];
    }

    private void AddIndexToPathRecursive_Altinn_App_SourceGenerator_Tests_Skjema(
        global::System.ReadOnlySpan<char> path,
        int pathOffset,
        global::System.ReadOnlySpan<int> rowIndexes,
        global::System.Span<char> buffer,
        ref int bufferOffset
    )
    {
        if (bufferOffset > 0)
        {
            buffer[bufferOffset++] = '.';
        }
        var segment = GetNextSegment(path, pathOffset, out pathOffset);
        switch (segment)
        {
            case "skjemainnhold":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 13;

                if (pathOffset != -1 && pathOffset < path.Length && path[pathOffset] == '[')
                {
                    // Copy index from path to buffer
                    GetIndex(path, pathOffset, out int nextPathIndexOffset);
                    path.Slice(pathOffset, nextPathIndexOffset).CopyTo(buffer.Slice(bufferOffset));
                    bufferOffset += nextPathIndexOffset - pathOffset;
                    pathOffset = nextPathIndexOffset;
                    rowIndexes = default;
                }
                else if (rowIndexes.Length >= 1)
                {
                    // Write index from rowIndexes to buffer
                    buffer[bufferOffset++] = '[';
                    rowIndexes[0].TryFormat(buffer.Slice(bufferOffset), out int charsWritten);
                    bufferOffset += charsWritten;
                    buffer[bufferOffset++] = ']';
                    rowIndexes = rowIndexes.Slice(1);
                }
                else
                {
                    // No index to write, return an empty path for error handling
                    bufferOffset = 0;
                    return;
                }
                if (pathOffset != -1)
                {
                    AddIndexToPathRecursive_Altinn_App_SourceGenerator_Tests_SkjemaInnhold(
                        path,
                        pathOffset,
                        rowIndexes,
                        buffer,
                        ref bufferOffset
                    );
                }
                return;
            case "eierAdresse":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 11;
                if (pathOffset != -1)
                {
                    AddIndexToPathRecursive_Altinn_App_SourceGenerator_Tests_Adresse(
                        path,
                        pathOffset,
                        rowIndexes,
                        buffer,
                        ref bufferOffset
                    );
                }
                return;
            case "skjemanummer":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 12;
                pathOffset += 12;
                return;
            case "skjemaversjon":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 13;
                pathOffset += 13;
                return;
            default:
                bufferOffset = 0;
                return;
        }
    }

    private void AddIndexToPathRecursive_Altinn_App_SourceGenerator_Tests_SkjemaInnhold(
        global::System.ReadOnlySpan<char> path,
        int pathOffset,
        global::System.ReadOnlySpan<int> rowIndexes,
        global::System.Span<char> buffer,
        ref int bufferOffset
    )
    {
        if (bufferOffset > 0)
        {
            buffer[bufferOffset++] = '.';
        }
        var segment = GetNextSegment(path, pathOffset, out pathOffset);
        switch (segment)
        {
            case "adresse":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 7;
                if (pathOffset != -1)
                {
                    AddIndexToPathRecursive_Altinn_App_SourceGenerator_Tests_Adresse(
                        path,
                        pathOffset,
                        rowIndexes,
                        buffer,
                        ref bufferOffset
                    );
                }
                return;
            case "tidligere-adresse":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 17;

                if (pathOffset != -1 && pathOffset < path.Length && path[pathOffset] == '[')
                {
                    // Copy index from path to buffer
                    GetIndex(path, pathOffset, out int nextPathIndexOffset);
                    path.Slice(pathOffset, nextPathIndexOffset).CopyTo(buffer.Slice(bufferOffset));
                    bufferOffset += nextPathIndexOffset - pathOffset;
                    pathOffset = nextPathIndexOffset;
                    rowIndexes = default;
                }
                else if (rowIndexes.Length >= 1)
                {
                    // Write index from rowIndexes to buffer
                    buffer[bufferOffset++] = '[';
                    rowIndexes[0].TryFormat(buffer.Slice(bufferOffset), out int charsWritten);
                    bufferOffset += charsWritten;
                    buffer[bufferOffset++] = ']';
                    rowIndexes = rowIndexes.Slice(1);
                }
                else
                {
                    // No index to write, return an empty path for error handling
                    bufferOffset = 0;
                    return;
                }
                if (pathOffset != -1)
                {
                    AddIndexToPathRecursive_Altinn_App_SourceGenerator_Tests_Adresse(
                        path,
                        pathOffset,
                        rowIndexes,
                        buffer,
                        ref bufferOffset
                    );
                }
                return;
            case "altinnRowId":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 11;
                pathOffset += 11;
                return;
            case "navn":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 4;
                pathOffset += 4;
                return;
            case "alder":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 5;
                pathOffset += 5;
                return;
            case "deltar":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 6;
                pathOffset += 6;
                return;
            default:
                bufferOffset = 0;
                return;
        }
    }

    private void AddIndexToPathRecursive_Altinn_App_SourceGenerator_Tests_Adresse(
        global::System.ReadOnlySpan<char> path,
        int pathOffset,
        global::System.ReadOnlySpan<int> rowIndexes,
        global::System.Span<char> buffer,
        ref int bufferOffset
    )
    {
        if (bufferOffset > 0)
        {
            buffer[bufferOffset++] = '.';
        }
        var segment = GetNextSegment(path, pathOffset, out pathOffset);
        switch (segment)
        {
            case "altinnRowId":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 11;
                pathOffset += 11;
                return;
            case "gate":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 4;
                pathOffset += 4;
                return;
            case "postnummer":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 10;
                pathOffset += 10;
                return;
            case "poststed":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 8;
                pathOffset += 8;
                return;
            default:
                bufferOffset = 0;
                return;
        }
    }

    #endregion AddIndexToPath
    #region Copy

    /// <inheritdoc />
    public global::Altinn.App.Core.Features.IFormDataWrapper Copy()
    {
        return new Altinn_App_SourceGenerator_Tests_SkjemaFormDataWrapper(CopyRecursive(_dataModel));
    }

    [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("data")]
    private static global::Altinn.App.SourceGenerator.Tests.Skjema? CopyRecursive(
        global::Altinn.App.SourceGenerator.Tests.Skjema? data
    )
    {
        if (data is null)
        {
            return null;
        }

        return new()
        {
            Skjemanummer = data.Skjemanummer,
            Skjemaversjon = data.Skjemaversjon,
            Skjemainnhold = CopyRecursive(data.Skjemainnhold),
            EierAdresse = CopyRecursive(data.EierAdresse),
        };
    }

    [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("list")]
    private static global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Tests.SkjemaInnhold?>? CopyRecursive(
        global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Tests.SkjemaInnhold?>? list
    )
    {
        if (list is null)
        {
            return null;
        }

        global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Tests.SkjemaInnhold?> result = new(list.Count);
        foreach (var item in list)
        {
            result.Add(CopyRecursive(item));
        }

        return result;
    }

    [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("data")]
    private static global::Altinn.App.SourceGenerator.Tests.SkjemaInnhold? CopyRecursive(
        global::Altinn.App.SourceGenerator.Tests.SkjemaInnhold? data
    )
    {
        if (data is null)
        {
            return null;
        }

        return new()
        {
            AltinnRowId = data.AltinnRowId,
            Navn = data.Navn,
            Alder = data.Alder,
            Deltar = data.Deltar,
            Adresse = CopyRecursive(data.Adresse),
            TidligereAdresse = CopyRecursive(data.TidligereAdresse),
        };
    }

    [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("data")]
    private static global::Altinn.App.SourceGenerator.Tests.Adresse? CopyRecursive(
        global::Altinn.App.SourceGenerator.Tests.Adresse? data
    )
    {
        if (data is null)
        {
            return null;
        }

        return new()
        {
            AltinnRowId = data.AltinnRowId,
            Gate = data.Gate,
            Postnummer = data.Postnummer,
            Poststed = data.Poststed,
        };
    }

    [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("list")]
    private static global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Tests.Adresse>? CopyRecursive(
        global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Tests.Adresse>? list
    )
    {
        if (list is null)
        {
            return null;
        }

        global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Tests.Adresse?> result = new(list.Count);
        foreach (var item in list)
        {
            result.Add(CopyRecursive(item));
        }

        return result;
    }

    #endregion Copy
    #region Remove

    /// <inheritdoc />
    public void RemoveField(global::System.ReadOnlySpan<char> path, global::Altinn.App.Core.Helpers.RowRemovalOption rowRemovalOption)
    {
        if (path.IsEmpty)
        {
            return;
        }

        RemoveRecursive(_dataModel, path, 0, rowRemovalOption);
    }

    private static void RemoveRecursive(
        global::Altinn.App.SourceGenerator.Tests.Skjema? model,
        global::System.ReadOnlySpan<char> path,
        int offset,
        global::Altinn.App.Core.Helpers.RowRemovalOption rowRemovalOption
    )
    {
        if (model is null)
        {
            return;
        }
        switch (GetNextSegment(path, offset, out int nextOffset))
        {
            case "skjemanummer" when nextOffset is -1:
                model.Skjemanummer = default;
                break;
            case "skjemaversjon" when nextOffset is -1:
                model.Skjemaversjon = default;
                break;
            case "skjemainnhold" when nextOffset is -1:
                model.Skjemainnhold = default;
                break;
            case "skjemainnhold":
                RemoveRecursive(model.Skjemainnhold, path, nextOffset, rowRemovalOption);
                break;
            case "eierAdresse" when nextOffset is -1:
                model.EierAdresse = default;
                break;
            case "eierAdresse":
                RemoveRecursive(model.EierAdresse, path, nextOffset, rowRemovalOption);
                break;
            default:
                // throw new ArgumentException("{path} is not a valid path.");
                return;
        }
    }

    private static void RemoveRecursive(
        global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Tests.SkjemaInnhold?>? model,
        global::System.ReadOnlySpan<char> path,
        int offset,
        global::Altinn.App.Core.Helpers.RowRemovalOption rowRemovalOption
    )
    {
        int index = GetIndex(path, offset, out int nextOffset);
        if (model is null || index < 0 || index >= model.Count)
        {
            return;
        }
        if (nextOffset == -1)
        {
            switch (rowRemovalOption)
            {
                case global::Altinn.App.Core.Helpers.RowRemovalOption.DeleteRow:
                    model.RemoveAt(index);
                    break;
                case global::Altinn.App.Core.Helpers.RowRemovalOption.SetToNull:
                    model[index] = null!;
                    break;
            }
        }
        else
        {
            RemoveRecursive(model?[index], path, nextOffset, rowRemovalOption);
        }
    }

    private static void RemoveRecursive(
        global::Altinn.App.SourceGenerator.Tests.SkjemaInnhold? model,
        global::System.ReadOnlySpan<char> path,
        int offset,
        global::Altinn.App.Core.Helpers.RowRemovalOption rowRemovalOption
    )
    {
        if (model is null)
        {
            return;
        }
        switch (GetNextSegment(path, offset, out int nextOffset))
        {
            case "navn" when nextOffset is -1:
                model.Navn = default;
                break;
            case "alder" when nextOffset is -1:
                model.Alder = default;
                break;
            case "deltar" when nextOffset is -1:
                model.Deltar = default;
                break;
            case "adresse" when nextOffset is -1:
                model.Adresse = default;
                break;
            case "adresse":
                RemoveRecursive(model.Adresse, path, nextOffset, rowRemovalOption);
                break;
            case "tidligere-adresse" when nextOffset is -1:
                model.TidligereAdresse = default;
                break;
            case "tidligere-adresse":
                RemoveRecursive(model.TidligereAdresse, path, nextOffset, rowRemovalOption);
                break;
            default:
                // throw new ArgumentException("{path} is not a valid path.");
                return;
        }
    }

    private static void RemoveRecursive(
        global::Altinn.App.SourceGenerator.Tests.Adresse? model,
        global::System.ReadOnlySpan<char> path,
        int offset,
        global::Altinn.App.Core.Helpers.RowRemovalOption rowRemovalOption
    )
    {
        if (model is null)
        {
            return;
        }
        switch (GetNextSegment(path, offset, out int nextOffset))
        {
            case "gate" when nextOffset is -1:
                model.Gate = default;
                break;
            case "postnummer" when nextOffset is -1:
                model.Postnummer = default;
                break;
            case "poststed" when nextOffset is -1:
                model.Poststed = default;
                break;
            default:
                // throw new ArgumentException("{path} is not a valid path.");
                return;
        }
    }

    private static void RemoveRecursive(
        global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Tests.Adresse>? model,
        global::System.ReadOnlySpan<char> path,
        int offset,
        global::Altinn.App.Core.Helpers.RowRemovalOption rowRemovalOption
    )
    {
        int index = GetIndex(path, offset, out int nextOffset);
        if (model is null || index < 0 || index >= model.Count)
        {
            return;
        }
        if (nextOffset == -1)
        {
            switch (rowRemovalOption)
            {
                case global::Altinn.App.Core.Helpers.RowRemovalOption.DeleteRow:
                    model.RemoveAt(index);
                    break;
                case global::Altinn.App.Core.Helpers.RowRemovalOption.SetToNull:
                    model[index] = null!;
                    break;
            }
        }
        else
        {
            RemoveRecursive(model?[index], path, nextOffset, rowRemovalOption);
        }
    }

    #endregion Remove
    #region AltinnRowIds

    /// <inheritdoc />
    public void RemoveAltinnRowIds()
    {
        SetAltinnRowIds(_dataModel, initialize: false);
    }

    /// <inheritdoc />
    public void InitializeAltinnRowIds()
    {
        SetAltinnRowIds(_dataModel, initialize: true);
    }

    private static void SetAltinnRowIds(global::Altinn.App.SourceGenerator.Tests.Skjema dataModel, bool initialize)
    {
        if(dataModel.Skjemainnhold is not null)
        {
            foreach (var item in dataModel.Skjemainnhold)
            {
                if (item is not null)
                {
                    SetAltinnRowIds(item, initialize);
                }
            }
        }
        if(dataModel.EierAdresse is not null)
        {
            SetAltinnRowIds(dataModel.EierAdresse, initialize);
        }
    }

    private static void SetAltinnRowIds(global::Altinn.App.SourceGenerator.Tests.SkjemaInnhold dataModel, bool initialize)
    {
        dataModel.AltinnRowId = initialize ? global::System.Guid.NewGuid() : global::System.Guid.Empty;
        if(dataModel.Adresse is not null)
        {
            SetAltinnRowIds(dataModel.Adresse, initialize);
        }
        if(dataModel.TidligereAdresse is not null)
        {
            foreach (var item in dataModel.TidligereAdresse)
            {
                if (item is not null)
                {
                    SetAltinnRowIds(item, initialize);
                }
            }
        }
    }

    private static void SetAltinnRowIds(global::Altinn.App.SourceGenerator.Tests.Adresse dataModel, bool initialize)
    {
        dataModel.AltinnRowId = initialize ? global::System.Guid.NewGuid() : global::System.Guid.Empty;
    }

    #endregion AltinnRowIds
    #region XmlStorage

    /// <inheritdoc />
    public void PrepareModelForXmlStorage()
    {
        global::Altinn.App.Core.Helpers.ObjectUtils.PrepareModelForXmlStorage(_dataModel);
    }

    #endregion XmlStorage
public static global::System.ReadOnlySpan<char> GetNextSegment(global::System.ReadOnlySpan<char> path, int offset, out int nextOffset)
{
    if (offset < 0 || offset >= path.Length)
    {
        throw new global::System.ArgumentOutOfRangeException(nameof(offset));
    }
    var segment = path[offset..];
    var periodOffset = global::System.MemoryExtensions.IndexOf(segment, '.');
    var bracketOffset = global::System.MemoryExtensions.IndexOf(segment, '[');
    var endOffset = (periodOffset, bracketOffset) switch
    {
        (-1, -1) => -1,
        (-1, _) => bracketOffset,
        (_, -1) => periodOffset,
        _ => global::System.Math.Min(periodOffset, bracketOffset),
    };
    if (endOffset == -1)
    {
        nextOffset = -1;
        return segment;
    }
    nextOffset = endOffset + offset + 1;

    return segment[..endOffset];
}

public static int GetIndex(global::System.ReadOnlySpan<char> path, int offset, out int nextOffset)
{
    var segment = path[offset..];
    var bracketOffset = global::System.MemoryExtensions.IndexOf(segment, ']');
    if (bracketOffset < 0)
    {
        throw new global::System.IndexOutOfRangeException();
    }

    if (!int.TryParse(segment[..bracketOffset], out var index))
    {
        throw new global::System.IndexOutOfRangeException();
    }

    nextOffset = offset + bracketOffset + 2;
    if (nextOffset >= path.Length)
    {
        nextOffset = -1;
    }

    return index;
}}

// --------------------------------------------------
// ModelPathNode as json (for debugging)
// --------------------------------------------------
//
// {
//   "JsonName": "",
//   "CSharpName": "",
//   "TypeName": "global::Altinn.App.SourceGenerator.Tests.Skjema",
//   "Properties": [
//     {
//       "JsonName": "skjemanummer",
//       "CSharpName": "Skjemanummer",
//       "TypeName": "string",
//     },
//     {
//       "JsonName": "skjemaversjon",
//       "CSharpName": "Skjemaversjon",
//       "TypeName": "string",
//     },
//     {
//       "JsonName": "skjemainnhold",
//       "CSharpName": "Skjemainnhold",
//       "TypeName": "global::Altinn.App.SourceGenerator.Tests.SkjemaInnhold",
//       "ListType": "global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Tests.SkjemaInnhold?>",
//       "Properties": [
//         {
//           "JsonName": "altinnRowId",
//           "CSharpName": "AltinnRowId",
//           "TypeName": "global::System.Guid",
//         },
//         {
//           "JsonName": "navn",
//           "CSharpName": "Navn",
//           "TypeName": "string",
//         },
//         {
//           "JsonName": "alder",
//           "CSharpName": "Alder",
//           "TypeName": "int",
//         },
//         {
//           "JsonName": "deltar",
//           "CSharpName": "Deltar",
//           "TypeName": "bool",
//         },
//         {
//           "JsonName": "adresse",
//           "CSharpName": "Adresse",
//           "TypeName": "global::Altinn.App.SourceGenerator.Tests.Adresse",
//           "Properties": [
//             {
//               "JsonName": "altinnRowId",
//               "CSharpName": "AltinnRowId",
//               "TypeName": "global::System.Guid",
//             },
//             {
//               "JsonName": "gate",
//               "CSharpName": "Gate",
//               "TypeName": "string",
//             },
//             {
//               "JsonName": "postnummer",
//               "CSharpName": "Postnummer",
//               "TypeName": "int",
//             },
//             {
//               "JsonName": "poststed",
//               "CSharpName": "Poststed",
//               "TypeName": "string",
//             }
//           ]
//         },
//         {
//           "JsonName": "tidligere-adresse",
//           "CSharpName": "TidligereAdresse",
//           "TypeName": "global::Altinn.App.SourceGenerator.Tests.Adresse",
//           "ListType": "global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Tests.Adresse>",
//           "Properties": [
//             {
//               "JsonName": "altinnRowId",
//               "CSharpName": "AltinnRowId",
//               "TypeName": "global::System.Guid",
//             },
//             {
//               "JsonName": "gate",
//               "CSharpName": "Gate",
//               "TypeName": "string",
//             },
//             {
//               "JsonName": "postnummer",
//               "CSharpName": "Postnummer",
//               "TypeName": "int",
//             },
//             {
//               "JsonName": "poststed",
//               "CSharpName": "Poststed",
//               "TypeName": "string",
//             }
//           ]
//         }
//       ]
//     },
//     {
//       "JsonName": "eierAdresse",
//       "CSharpName": "EierAdresse",
//       "TypeName": "global::Altinn.App.SourceGenerator.Tests.Adresse",
//       "Properties": [
//         {
//           "JsonName": "altinnRowId",
//           "CSharpName": "AltinnRowId",
//           "TypeName": "global::System.Guid",
//         },
//         {
//           "JsonName": "gate",
//           "CSharpName": "Gate",
//           "TypeName": "string",
//         },
//         {
//           "JsonName": "postnummer",
//           "CSharpName": "Postnummer",
//           "TypeName": "int",
//         },
//         {
//           "JsonName": "poststed",
//           "CSharpName": "Poststed",
//           "TypeName": "string",
//         }
//       ]
//     }
//   ]
// }
