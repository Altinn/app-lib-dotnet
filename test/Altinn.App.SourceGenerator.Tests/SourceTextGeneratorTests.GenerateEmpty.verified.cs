// <auto-generated/>
#nullable enable
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using Altinn.App.Core.Features;
using Altinn.App.Core.Helpers;

internal class Altinn_App_SourceGenerator_Tests_EmptyFormDataWrapper
    : IFormDataWrapper<global::Altinn.App.SourceGenerator.Tests.Empty>
{
    private readonly global::Altinn.App.SourceGenerator.Tests.Empty _dataModel;

    public Type BackingDataType => typeof(global::Altinn.App.SourceGenerator.Tests.Empty);

    public T BackingData<T>()
        where T : class
    {
        return _dataModel as T
            ?? throw new InvalidCastException(
                $"Attempted to cast data model of type Altinn.App.SourceGenerator.Tests.Empty to {typeof(T).FullName}"
            );
    }

    public Altinn_App_SourceGenerator_Tests_EmptyFormDataWrapper(object dataModel)
    {
        _dataModel =
            dataModel as global::Altinn.App.SourceGenerator.Tests.Empty
            ?? throw new ArgumentException(
                $"Data model must be of type Altinn.App.SourceGenerator.Tests.Empty, (was {dataModel.GetType().FullName})"
            );
    }

    #region Getters

    /// <inheritdoc />
    public object? Get(ReadOnlySpan<char> path) => null;

    #endregion Getters
    #region AddIndexToPath

    /// <inheritdoc />
    public ReadOnlySpan<char> AddIndexToPath(ReadOnlySpan<char> path, ReadOnlySpan<int> rowIndexes, Span<char> buffer)
    {
        var bufferOffset = 0;
        var pathOffset = 0;

        AddIndexToPathRecursive_Altinn_App_SourceGenerator_Tests_Empty(
            buffer,
            path,
            rowIndexes,
            ref bufferOffset,
            ref pathOffset
        );

        return buffer[..bufferOffset];
    }

    private void AddIndexToPathRecursive_Altinn_App_SourceGenerator_Tests_Empty(
        Span<char> buffer,
        ReadOnlySpan<char> path,
        ReadOnlySpan<int> rowIndexes,
        ref int bufferOffset,
        ref int pathOffset
    )
    {
        if (bufferOffset > 0)
        {
            buffer[bufferOffset++] = '.';
        }
        var segment = GetNextSegment(path, pathOffset, out pathOffset);
        switch (segment)
        {
            default:
                bufferOffset = 0;
                return;
        }
    }

    #endregion AddIndexToPath
    #region Copy

    /// <inheritdoc />
    public IFormDataWrapper Copy()
    {
        return new Altinn_App_SourceGenerator_Tests_EmptyFormDataWrapper(CopyRecursive(_dataModel));
    }

    [return: NotNullIfNotNull("data")]
    private static global::Altinn.App.SourceGenerator.Tests.Empty? CopyRecursive(
        global::Altinn.App.SourceGenerator.Tests.Empty? data
    )
    {
        if (data is null)
        {
            return null;
        }

        return new();
    }

    #endregion Copy
    #region Remove

    /// <inheritdoc />
    public void RemoveField(ReadOnlySpan<char> path, RowRemovalOption rowRemovalOption) { }

    #endregion Remove
    #region AltinnRowIds

    /// <inheritdoc />
    public void RemoveAltinnRowIds() { }

    /// <inheritdoc />
    public void InitializeAltinnRowIds() { }

    #endregion AltinnRowIds
    #region XmlStorage

    /// <inheritdoc />
    public void PrepareModelForXmlStorage()
    {
        ObjectUtils.PrepareModelForXmlStorage(_dataModel);
    }

    #endregion XmlStorage
public static ReadOnlySpan<char> GetNextSegment(ReadOnlySpan<char> path, int offset, out int nextOffset)
{
    if (offset < 0 || offset >= path.Length)
    {
        throw new ArgumentOutOfRangeException(nameof(offset));
    }
    var segment = path[offset..];
    var periodOffset = segment.IndexOf('.');
    var bracketOffset = segment.IndexOf('[');
    var endOffset = (periodOffset, bracketOffset) switch
    {
        (-1, -1) => -1,
        (-1, _) => bracketOffset,
        (_, -1) => periodOffset,
        _ => Math.Min(periodOffset, bracketOffset),
    };
    if (endOffset == -1)
    {
        nextOffset = -1;
        return segment;
    }
    nextOffset = endOffset + offset + 1;

    return segment[..endOffset];
}

public static int GetIndex(ReadOnlySpan<char> path, int offset, out int nextOffset)
{
    var segment = path[offset..];
    var bracketOffset = segment.IndexOf(']');
    if (bracketOffset < 0)
    {
        throw new IndexOutOfRangeException();
    }

    if (!int.TryParse(segment[..bracketOffset], out var index))
    {
        throw new IndexOutOfRangeException();
    }

    nextOffset = offset + bracketOffset + 2;
    if (nextOffset >= path.Length)
    {
        nextOffset = -1;
    }

    return index;
}}

// --------------------------------------------------
// ModelPathNode as json (for debugging)
// --------------------------------------------------
//
// {
//   "JsonName": "",
//   "CSharpName": "",
//   "TypeName": "global::Altinn.App.SourceGenerator.Tests.Empty",
// }
