// <auto-generated/>
#nullable enable

internal class Altinn_App_SourceGenerator_Tests_EmptyFormDataWrapper
    : global::Altinn.App.Core.Features.IFormDataWrapper<global::Altinn.App.SourceGenerator.Tests.Empty>
{
    private readonly global::Altinn.App.SourceGenerator.Tests.Empty _dataModel;

    public global::System.Type BackingDataType => typeof(global::Altinn.App.SourceGenerator.Tests.Empty);

    public T BackingData<T>()
        where T : class
    {
        return _dataModel as T
            ?? throw new global::System.InvalidCastException(
                $"Attempted to cast data model of type Altinn.App.SourceGenerator.Tests.Empty to {typeof(T).FullName}"
            );
    }

    public Altinn_App_SourceGenerator_Tests_EmptyFormDataWrapper(object dataModel)
    {
        _dataModel =
            dataModel as global::Altinn.App.SourceGenerator.Tests.Empty
            ?? throw new global::System.ArgumentException(
                $"Data model must be of type Altinn.App.SourceGenerator.Tests.Empty, (was {dataModel?.GetType().FullName ?? "null"})"
            );
    }

    #region Getters

    /// <inheritdoc />
    public object? Get(global::System.ReadOnlySpan<char> path) => null;

    #endregion Getters
    #region AddIndexToPath

    /// <inheritdoc />
    public global::System.ReadOnlySpan<char> AddIndexToPath(global::System.ReadOnlySpan<char> path, global::System.ReadOnlySpan<int> rowIndexes, global::System.Span<char> buffer)
    {
        var bufferOffset = 0;
        var pathOffset = 0;

        AddIndexToPathRecursive_Altinn_App_SourceGenerator_Tests_Empty(
            path,
            pathOffset,
            rowIndexes,
            buffer,
            ref bufferOffset
        );

        return buffer[..bufferOffset];
    }

    private void AddIndexToPathRecursive_Altinn_App_SourceGenerator_Tests_Empty(
        global::System.ReadOnlySpan<char> path,
        int pathOffset,
        global::System.ReadOnlySpan<int> rowIndexes,
        global::System.Span<char> buffer,
        ref int bufferOffset
    )
    {
        if (bufferOffset > 0)
        {
            buffer[bufferOffset++] = '.';
        }
        var segment = GetNextSegment(path, pathOffset, out pathOffset);
        switch (segment)
        {
            default:
                bufferOffset = 0;
                return;
        }
    }

    #endregion AddIndexToPath
    #region Copy

    /// <inheritdoc />
    public global::Altinn.App.Core.Features.IFormDataWrapper Copy()
    {
        return new Altinn_App_SourceGenerator_Tests_EmptyFormDataWrapper(CopyRecursive(_dataModel));
    }

    [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("data")]
    private static global::Altinn.App.SourceGenerator.Tests.Empty? CopyRecursive(
        global::Altinn.App.SourceGenerator.Tests.Empty? data
    )
    {
        if (data is null)
        {
            return null;
        }

        return new();
    }

    #endregion Copy
    #region Remove

    /// <inheritdoc />
    public void RemoveField(global::System.ReadOnlySpan<char> path, global::Altinn.App.Core.Helpers.RowRemovalOption rowRemovalOption) { }

    #endregion Remove
    #region AltinnRowIds

    /// <inheritdoc />
    public void RemoveAltinnRowIds() { }

    /// <inheritdoc />
    public void InitializeAltinnRowIds() { }

    #endregion AltinnRowIds
    #region XmlStorage

    /// <inheritdoc />
    public void PrepareModelForXmlStorage()
    {
        global::Altinn.App.Core.Helpers.ObjectUtils.PrepareModelForXmlStorage(_dataModel);
    }

    #endregion XmlStorage
public static global::System.ReadOnlySpan<char> GetNextSegment(global::System.ReadOnlySpan<char> path, int offset, out int nextOffset)
{
    if (offset < 0 || offset >= path.Length)
    {
        throw new global::System.ArgumentOutOfRangeException(nameof(offset));
    }
    var segment = path[offset..];
    var periodOffset = global::System.MemoryExtensions.IndexOf(segment, '.');
    var bracketOffset = global::System.MemoryExtensions.IndexOf(segment, '[');
    var endOffset = (periodOffset, bracketOffset) switch
    {
        (-1, -1) => -1,
        (-1, _) => bracketOffset,
        (_, -1) => periodOffset,
        _ => global::System.Math.Min(periodOffset, bracketOffset),
    };
    if (endOffset == -1)
    {
        nextOffset = -1;
        return segment;
    }
    nextOffset = endOffset + offset + 1;

    return segment[..endOffset];
}

public static int GetIndex(global::System.ReadOnlySpan<char> path, int offset, out int nextOffset)
{
    var segment = path[offset..];
    var bracketOffset = global::System.MemoryExtensions.IndexOf(segment, ']');
    if (bracketOffset < 0)
    {
        throw new global::System.IndexOutOfRangeException();
    }

    if (!int.TryParse(segment[..bracketOffset], out var index))
    {
        throw new global::System.IndexOutOfRangeException();
    }

    nextOffset = offset + bracketOffset + 2;
    if (nextOffset >= path.Length)
    {
        nextOffset = -1;
    }

    return index;
}}

// --------------------------------------------------
// ModelPathNode as json (for debugging)
// --------------------------------------------------
//
// {
//   "JsonName": "",
//   "CSharpName": "",
//   "TypeName": "global::Altinn.App.SourceGenerator.Tests.Empty",
// }
