using System.Text;

namespace Altinn.App.Analyzers.SourceTextGenerator;

/// <summary>
/// Generates source text for the IFormDataWrapper implementations.
/// </summary>
public static class SourceTextGenerator
{
    /// <summary>
    /// Generates the source text for the IFormDataWrapper implementation for the given root node.
    /// </summary>
    public static string GenerateSourceText(ModelPathNode rootNode, string classModifier)
    {
        var builder = new StringBuilder();
        builder.Append("// <auto-generated/>\r\n");
        var className = $"{rootNode.Name}FormDataWrapper";
        builder.Append(
            $$"""
            #nullable enable

            [global::System.CodeDom.Compiler.GeneratedCode]
            [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
            {{classModifier}} sealed class {{className}}
                : global::Altinn.App.Core.Features.IFormDataWrapper<{{rootNode.TypeName}}>
            {
                private readonly {{rootNode.TypeName}} _dataModel;

                public global::System.Type BackingDataType => typeof({{rootNode.TypeName}});

                public T BackingData<T>()
                    where T : class
                {
                    return _dataModel as T
                        ?? throw new global::System.InvalidCastException(
                            $"Attempted to cast data model of type {{rootNode.FullName}} to {typeof(T).FullName}"
                        );
                }

                public {{rootNode.Name}}FormDataWrapper(object dataModel)
                {
                    _dataModel =
                        dataModel as {{rootNode.TypeName}}
                        ?? throw new global::System.ArgumentException(
                            $"Data model must be of type {{rootNode.FullName}}, (was {dataModel?.GetType().FullName ?? "null"})"
                        );
                }

            """
        );
        builder.Append("\r\n    #region Getters\r\n");
        GetterGenerator.Generate(builder, rootNode);
        builder.Append("\r\n    #endregion Getters\r\n");
        builder.Append("    #region AddIndexToPath\r\n");
        AddIndexToPathGenerator.Generate(builder, rootNode);
        builder.Append("\r\n    #endregion AddIndexToPath\r\n");
        builder.Append("    #region Copy\r\n");
        CopyGenerator.Generate(builder, rootNode, className);
        builder.Append("\r\n    #endregion Copy\r\n");
        builder.Append("    #region Remove\r\n");
        RemoveGenerator.Generate(builder, rootNode);
        builder.Append("\r\n    #endregion Remove\r\n");
        builder.Append("    #region AltinnRowIds\r\n");
        AltinnRowIdsGenerator.Generate(builder, rootNode);
        builder.Append("\r\n    #endregion AltinnRowIds\r\n");
        builder.Append("    #region XmlStorage\r\n");
        PrepareModelForXmlStorageGenerator.Generate(builder, rootNode);
        builder.Append("\r\n    #endregion XmlStorage\r\n");

        builder.Append(
            """
                private static global::System.ReadOnlySpan<char> GetNextSegment(global::System.ReadOnlySpan<char> path, int offset, out int nextOffset)
                {
                    if (offset < 0 || offset >= path.Length)
                    {
                        throw new global::System.ArgumentOutOfRangeException(nameof(offset));
                    }
                    var segment = path[offset..];
                    var periodOffset = global::System.MemoryExtensions.IndexOf(segment, '.');
                    var bracketOffset = global::System.MemoryExtensions.IndexOf(segment, '[');
                    var endOffset = (periodOffset, bracketOffset) switch
                    {
                        (-1, -1) => -1,
                        (-1, _) => bracketOffset,
                        (_, -1) => periodOffset,
                        _ => global::System.Math.Min(periodOffset, bracketOffset),
                    };
                    if (endOffset == -1)
                    {
                        nextOffset = -1;
                        return segment;
                    }
                    nextOffset = endOffset + offset + 1;

                    return segment[..endOffset];
                }

                private static int GetIndex(global::System.ReadOnlySpan<char> path, int offset, out int nextOffset)
                {
                    var segment = path[offset..];
                    var bracketOffset = global::System.MemoryExtensions.IndexOf(segment, ']');
                    if (bracketOffset < 0)
                    {
                        throw new global::System.FormatException($"Missing closing bracket ']' in {path}.");
                    }

                    if (!int.TryParse(segment[..bracketOffset], out var index))
                    {
                        throw new global::System.FormatException($"Invalid index in {path}.");
                    }

                    if (index < 0)
                    {
                        throw new global::System.FormatException($"Invalid negative index in {path}.");
                    }

                    nextOffset = offset + bracketOffset + 2;
                    if (nextOffset >= path.Length)
                    {
                        nextOffset = -1;
                    }

                    return index;
                }

            """
        );
        builder.Append("}\r\n");

        GenerateJsonComment.Generate(builder, rootNode);

        return builder.ToString();
    }
}
