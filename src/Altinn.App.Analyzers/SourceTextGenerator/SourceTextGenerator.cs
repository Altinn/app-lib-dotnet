using System.Text;

namespace Altinn.App.Analyzers.SourceTextGenerator;

/// <summary>
/// Generates source text for the IFormDataWrapper implementations.
/// </summary>
public static class SourceTextGenerator
{
    /// <summary>
    /// Generates the source text for the IFormDataWrapper implementation for the given root node.
    /// </summary>
    public static string GenerateSourceText(ModelPathNode rootNode, string classModifier)
    {
        var builder = new StringBuilder();
        builder.Append("// <auto-generated/>\r\n");
        var className = $"{rootNode.Name}FormDataWrapper";
        builder.Append(
            $$"""
            #nullable enable
            using System;
            using System.Collections.Generic;
            using System.Diagnostics.CodeAnalysis;
            using System.Linq;
            using Altinn.App.Core.Features;
            using Altinn.App.Core.Helpers;

            {{classModifier}} class {{className}}
                : IFormDataWrapper<{{rootNode.TypeName}}>
            {
                private readonly {{rootNode.TypeName}} _dataModel;

                public Type BackingDataType => typeof({{rootNode.TypeName}});

                public T BackingData<T>()
                    where T : class
                {
                    return _dataModel as T
                        ?? throw new InvalidCastException(
                            $"Attempted to cast data model of type {{rootNode.FullName}} to {typeof(T).FullName}"
                        );
                }

                public {{rootNode.Name}}FormDataWrapper(object dataModel)
                {
                    _dataModel =
                        dataModel as {{rootNode.TypeName}}
                        ?? throw new ArgumentException(
                            $"Data model must be of type {{rootNode.FullName}}, (was {dataModel.GetType().FullName})"
                        );
                }

            """
        );
        builder.Append("\r\n    #region Getters\r\n");
        GetterGenerator.Generate(builder, rootNode);
        builder.Append("\r\n    #endregion Getters\r\n");
        builder.Append("    #region AddIndexToPath\r\n");
        AddIndexToPathGenerator.Generate(builder, rootNode);
        builder.Append("\r\n    #endregion AddIndexToPath\r\n");
        builder.Append("    #region Copy\r\n");
        CopyGenerator.Generate(builder, rootNode, className);
        builder.Append("\r\n    #endregion Copy\r\n");
        builder.Append("    #region Remove\r\n");
        RemoveGenerator.Generate(builder, rootNode);
        builder.Append("\r\n    #endregion Remove\r\n");
        builder.Append("    #region AltinnRowIds\r\n");
        AltinnRowIdsGenerator.Generate(builder, rootNode);
        builder.Append("\r\n    #endregion AltinnRowIds\r\n");
        builder.Append("    #region XmlStorage\r\n");
        PrepareModelForXmlStorageGenerator.Generate(builder, rootNode);
        builder.Append("\r\n    #endregion XmlStorage\r\n");

        builder.Append(
            """
            public static ReadOnlySpan<char> GetNextSegment(ReadOnlySpan<char> path, int offset, out int nextOffset)
            {
                if (offset < 0 || offset >= path.Length)
                {
                    throw new ArgumentOutOfRangeException(nameof(offset));
                }
                var segment = path[offset..];
                var periodOffset = segment.IndexOf('.');
                var bracketOffset = segment.IndexOf('[');
                var endOffset = (periodOffset, bracketOffset) switch
                {
                    (-1, -1) => -1,
                    (-1, _) => bracketOffset,
                    (_, -1) => periodOffset,
                    _ => Math.Min(periodOffset, bracketOffset),
                };
                if (endOffset == -1)
                {
                    nextOffset = -1;
                    return segment;
                }
                nextOffset = endOffset + offset + 1;

                return segment[..endOffset];
            }

            public static int GetIndex(ReadOnlySpan<char> path, int offset, out int nextOffset)
            {
                var segment = path[offset..];
                var bracketOffset = segment.IndexOf(']');
                if (bracketOffset < 0)
                {
                    throw new IndexOutOfRangeException();
                }

                if (!int.TryParse(segment[..bracketOffset], out var index))
                {
                    throw new IndexOutOfRangeException();
                }

                nextOffset = offset + bracketOffset + 2;
                if (nextOffset >= path.Length)
                {
                    nextOffset = -1;
                }

                return index;
            }
            """
        );
        builder.Append("}\r\n");

        GenerateJsonComment.Generate(builder, rootNode);

        return builder.ToString();
    }
}
